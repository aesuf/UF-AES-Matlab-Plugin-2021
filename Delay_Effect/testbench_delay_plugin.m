function out = testbench_delay_plugin
% TESTBENCH_DELAY_PLUGIN Exercise audio plug-in class
% to check for violations of plug-in constraints and other errors.
%
% OUT = TESTBENCH_DELAY_PLUGIN Return the output data from the
% plug-in. This is useful to verify that plug-in numeric behavior has not
% changed, when you are changing your plug-in in ways that should not
% affect that behavior (eg, refactoring code).
%
% You can test whether your MATLAB plug-in code is ready for code
% generation by creating and running a mex function from this testbench:
%
%   codegen testbench_delay_plugin    % Create the mex function
%   testbench_delay_plugin_mex        % Run the mex function
%
% You can use this testbench as a template and edit it to meet your
% testing needs. Rename the file to ensure your work is not
% accidentally overwritten and lost by another run of
% validateAudioPlugin.
%
% Automatically generated by validateAudioPlugin 21-May-2021 13:57:44

% Set basic test parameters
sampleRates = [44100, 48000, 96000, 192000, 32000];
frameSizes = [ 2.^(1:13) 2.^(2:13)-1 2.^(1:13)+1];
totalFrameSize = sum(frameSizes);

% Create output buffer if requested
if nargout > 0
    nout = 2;
    obuf = zeros(totalFrameSize*numel(sampleRates), nout);
    optr = 1;
end

% Instantiate the plug-in
plugin = delay_plugin;
% Initialize enumeration to enable code generation
plugin.bypass = 'On';
plugin.bypass = 'Off';
plugin.type = 'ping-pong';
plugin.type = 'basic';
plugin.time_L = '1/1';
plugin.time_L = '1/16';
plugin.time_L = '1/16D';
plugin.time_L = '1/16T';
plugin.time_L = '1/2';
plugin.time_L = '1/2D';
plugin.time_L = '1/2T';
plugin.time_L = '1/4D';
plugin.time_L = '1/4T';
plugin.time_L = '1/8';
plugin.time_L = '1/8D';
plugin.time_L = '1/8T';
plugin.time_L = '1/4';
plugin.time_R = '1/1';
plugin.time_R = '1/16';
plugin.time_R = '1/16D';
plugin.time_R = '1/16T';
plugin.time_R = '1/2';
plugin.time_R = '1/2D';
plugin.time_R = '1/2T';
plugin.time_R = '1/4D';
plugin.time_R = '1/4T';
plugin.time_R = '1/8';
plugin.time_R = '1/8D';
plugin.time_R = '1/8T';
plugin.time_R = '1/4';

% Test at each sample rate
for sampleRate = sampleRates
    paramState = initParamState(plugin);
    
    % Tell plug-in the current sample rate
    setSampleRate(plugin, sampleRate);
    
    % Plug-in has no reset method to call after setting sample rate
    
    % Create input data: logarithmically swept sine waves, with a
    % different initial phase for each channel
    phaseOffsets = (0:1)/1 * 0.5 * pi;
    ibuf = logchirp(20, 20e3, sampleRate, totalFrameSize, phaseOffsets);
    iptr = 1;
    
    % Process data using different frame sizes
    for i = 1:numel(frameSizes)
        samplesPerFrame = frameSizes(i);
        
        val = fromNormalizedbypass(mod(floor((i-1)./1),3)/2);
        plugin.bypass = val;
        paramState.bypass = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''bypass''');
        
        val = fromNormalizedmix(mod(floor((i-1)./3),3)/2);
        plugin.mix = val;
        paramState.mix = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''mix''');
        
        val = fromNormalizedtype(mod(floor((i-1)./9),3)/2);
        plugin.type = val;
        paramState.type = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''type''');
        
        val = fromNormalizedL_Gain(mod(floor((i-1)./27),3)/2);
        plugin.L_Gain = val;
        paramState.L_Gain = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''L_Gain''');
        
        val = fromNormalizedR_Gain(mod(floor((i-1)./81),3)/2);
        plugin.R_Gain = val;
        paramState.R_Gain = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''R_Gain''');
        
        val = fromNormalizedtime_L(mod(floor((i-1)./243),3)/2);
        plugin.time_L = val;
        paramState.time_L = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''time_L''');
        
        val = fromNormalizedtime_R(mod(floor((i-1)./729),3)/2);
        plugin.time_R = val;
        paramState.time_R = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''time_R''');
        
        val = fromNormalizedL_Feedback(mod(floor((i-1)./2187),3)/2);
        plugin.L_Feedback = val;
        paramState.L_Feedback = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''L_Feedback''');
        
        val = fromNormalizedR_Feedback(mod(floor((i-1)./6561),3)/2);
        plugin.R_Feedback = val;
        paramState.R_Feedback = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''R_Feedback''');
        
        val = fromNormalizedTempo(mod(floor((i-1)./19683),3)/2);
        plugin.Tempo = val;
        paramState.Tempo = val;
        checkForTampering(plugin, paramState, sampleRate, ...
            'Setting parameter ''Tempo''');
        
        % Get a frame of input data
        in = ibuf(iptr:iptr+samplesPerFrame-1, :);
        iptr = iptr + samplesPerFrame;
        
        % Run the plug-in
        o1 = process(plugin, in(:,1:2));
        
        % Save the output data if requested
        if nargout > 0
            obuf(optr:optr+samplesPerFrame-1, :) = o1;
            optr = optr + samplesPerFrame;
        end
        
        % Verify class and size of outputs
        if ~isa(o1, 'double')
            error('ValidateAudioPlugin:OutputNotDouble', ...
                ['Output 1 is of class %s, ' ...
                'but should have been double.'], ...
                class(o1));
        end
        if size(o1,1) ~= samplesPerFrame
            error('ValidateAudioPlugin:BadOutputFrameSize', ...
                ['Output 1 produced a frame size of %d, ' ...
                'but should have matched the input frame size of %d.'], ...
                size(o1,1), samplesPerFrame);
        end
        if size(o1,2) ~= 2
            error('ValidateAudioPlugin:BadOutputWidth', ...
                ['Width of output 1 was %d, ' ...
                'but should have been 2 (OutputChannels(1)).'], ...
                size(o1,2));
        end
        checkForTampering(plugin, paramState, sampleRate, 'Running plugin');
    end
end

% Return output data if requested
if nargout > 0
    out = obuf;
end
end

function checkForTampering(plugin, paramState, sampleRate, cause)
% Verify parameters were not tampered with
if ~isequal(paramState.bypass, plugin.bypass)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''bypass'' from ''%s'' to ''%s'.'', ...
        cause, paramState.bypass, plugin.bypass);
end
if ~isequal(paramState.mix, plugin.mix)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''mix'' from %g to %g.', ...
        cause, paramState.mix, plugin.mix);
end
if ~isequal(paramState.type, plugin.type)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''type'' from ''%s'' to ''%s'.'', ...
        cause, paramState.type, plugin.type);
end
if ~isequal(paramState.L_Gain, plugin.L_Gain)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''L_Gain'' from %g to %g.', ...
        cause, paramState.L_Gain, plugin.L_Gain);
end
if ~isequal(paramState.R_Gain, plugin.R_Gain)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''R_Gain'' from %g to %g.', ...
        cause, paramState.R_Gain, plugin.R_Gain);
end
if ~isequal(paramState.time_L, plugin.time_L)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''time_L'' from ''%s'' to ''%s'.'', ...
        cause, paramState.time_L, plugin.time_L);
end
if ~isequal(paramState.time_R, plugin.time_R)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''time_R'' from ''%s'' to ''%s'.'', ...
        cause, paramState.time_R, plugin.time_R);
end
if ~isequal(paramState.L_Feedback, plugin.L_Feedback)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''L_Feedback'' from %g to %g.', ...
        cause, paramState.L_Feedback, plugin.L_Feedback);
end
if ~isequal(paramState.R_Feedback, plugin.R_Feedback)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''R_Feedback'' from %g to %g.', ...
        cause, paramState.R_Feedback, plugin.R_Feedback);
end
if ~isequal(paramState.Tempo, plugin.Tempo)
    error('ValidateAudioPlugin:ParamChanged', ...
        '%s changed parameter ''Tempo'' from %g to %g.', ...
        cause, paramState.Tempo, plugin.Tempo);
end
% Verify sample rate was not tampered with
if ~isequal(getSampleRate(plugin), sampleRate)
    error('ValidateAudioPlugin:SampleRateChanged', ...
        '%s changed sample rate from %g to %g.', ...
        cause, sampleRate, getSampleRate(plugin));
end
end

function y = logchirp(f0, f1, Fs, nsamples, initialPhase)
% logarithmically swept sine from f0 to f1 over nsamples, at Fs
y = zeros(nsamples,numel(initialPhase));
instPhi = logInstantaneousPhase(f0, f1, Fs, nsamples);
for i = 1:numel(initialPhase)
    y(:,i) = sin(instPhi + initialPhase(i));
end
end

function phi = logInstantaneousPhase(f0, f1, Fs, n)
final = n-1;
t = (0:final)/final;
t1 = final/Fs;
phi = 2*pi * t1/log(f1/f0) * (f0 * (f1/f0).^(t') - f0);
end

function paramState = initParamState(plugin)
paramState.bypass = plugin.bypass;
paramState.mix = plugin.mix;
paramState.type = plugin.type;
paramState.L_Gain = plugin.L_Gain;
paramState.R_Gain = plugin.R_Gain;
paramState.time_L = plugin.time_L;
paramState.time_R = plugin.time_R;
paramState.L_Feedback = plugin.L_Feedback;
paramState.R_Feedback = plugin.R_Feedback;
paramState.Tempo = plugin.Tempo;
end

function val = fromNormalizedbypass(normval)
idx = floor( 0.5 + normval * 1);
switch idx
    case 0
        val = 'On';
    otherwise
        val = 'Off';
end
end

function val = fromNormalizedmix(normval)
val = 0 + (1-0)*normval;
end

function val = fromNormalizedtype(normval)
idx = floor( 0.5 + normval * 1);
switch idx
    case 0
        val = 'basic';
    otherwise
        val = 'ping-pong';
end
end

function val = fromNormalizedL_Gain(normval)
val = -10 + (6--10)*normval.^0.333333;
end

function val = fromNormalizedR_Gain(normval)
val = -10 + (6--10)*normval.^0.333333;
end

function val = fromNormalizedtime_L(normval)
idx = floor( 0.5 + normval * 12);
switch idx
    case 0
        val = '1/16T';
    case 1
        val = '1/16D';
    case 2
        val = '1/16';
    case 3
        val = '1/8T';
    case 4
        val = '1/8D';
    case 5
        val = '1/8';
    case 6
        val = '1/4T';
    case 7
        val = '1/4D';
    case 8
        val = '1/4';
    case 9
        val = '1/2T';
    case 10
        val = '1/2D';
    case 11
        val = '1/2';
    otherwise
        val = '1/1';
end
end

function val = fromNormalizedtime_R(normval)
idx = floor( 0.5 + normval * 12);
switch idx
    case 0
        val = '1/16T';
    case 1
        val = '1/16D';
    case 2
        val = '1/16';
    case 3
        val = '1/8T';
    case 4
        val = '1/8D';
    case 5
        val = '1/8';
    case 6
        val = '1/4T';
    case 7
        val = '1/4D';
    case 8
        val = '1/4';
    case 9
        val = '1/2T';
    case 10
        val = '1/2D';
    case 11
        val = '1/2';
    otherwise
        val = '1/1';
end
end

function val = fromNormalizedL_Feedback(normval)
val = 0 + (1-0)*normval;
end

function val = fromNormalizedR_Feedback(normval)
val = 0 + (1-0)*normval;
end

function val = fromNormalizedTempo(normval)
val = floor(0.5 + 1 + (999-1)*normval);
end
